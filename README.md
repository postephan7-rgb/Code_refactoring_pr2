# Code_refactoring_pr2


### Вариант: 2 поиск отсутствующего числа

---

## Оценка до рефакторинга

```csharp

using System;
using System.Diagnostics;

class Program
{
    static int FindMissingNumber(int[] nums, int n)
    {
        for (int i = 0; i <= n; i++)
        {
            bool found = false;
            for (int j = 0; j < nums.Length; j++)
            {
                if (nums[j] == i)
                {
                    found = true;
                    break;
                }
            }
            if (!found) return i;
        }
        return -1;
    }

    static void Main()
    {
        int n = 5;
        int[] nums = { 0, 1, 2, 3, 5 };
        Stopwatch sw = Stopwatch.StartNew();
        int missing = FindMissingNumber(nums, n);
        sw.Stop();
        Console.WriteLine("Отсутствующее число: " + missing);
        Console.WriteLine("Время: " + sw.ElapsedTicks + " тиков");
    }
}
```

### Оценка сложности алгоритма

Внутри метода `FindMissingNumber` используются два вложенных цикла:

 внешний цикл по всем возможным числам `i` от `0` до `n`;
 внутренний цикл по всем элементам массива `nums`.

Для каждого кандидата `i` выполняется полный проход по массиву:

 количество итераций внешнего цикла пропорционально `n`;
 количество итераций внутреннего цикла также пропорционально `n`.

Примерная формула количества операций:

`T(n) ≈ a * n² + b * n + c`

**Асимптотическая сложность:**  
`T(n) = O(n²)`

### Время выполнения программы при разных N

| N      | Среднее время (тики) |
|--------|----------------------|
| 100    | 2 469                |
| 1 000  | 166 555              |
| 5 000  | 3 972 097            |
| 10 000 | 15 955 680           |

По мере увеличения `N` время работы растет квадратично, что делает алгоритм неэффективным на больших массивах.

### Пример работы программы до рефакторинга

```text
Отсутствующее число: 4
Время: 1234 тиков
```

## Оценка после рефакторинга

```csharp

using System;
using System.Diagnostics;

class Program2
{
    // Оптимальный поиск отсутствующего числа (O(n))
    static int FindMissingNumber(int[] numbers, int n)
    {
        int expectedSum = n * (n + 1) / 2;
        int actualSum = 0;

        for (int i = 0; i < numbers.Length; i++)
        {
            actualSum += numbers[i];
        }

        return expectedSum - actualSum;
    }

    static void Main()
    {
        int n = 5;
        int[] numbers = { 0, 1, 2, 3, 5 };

        var sw = Stopwatch.StartNew();
        int missing = FindMissingNumber(numbers, n);
        sw.Stop();

        Console.WriteLine("Отсутствующее число: " + missing);
        Console.WriteLine("Время: " + sw.ElapsedTicks + " тиков");
    }
}
```

### Оценка сложности алгоритма после рефакторинга

Идея оптимизированного алгоритма:

1. Вычислить ожидаемую сумму всех чисел от `0` до `n` по формуле:
   \[
   S_{\text{expected}} = \frac{n (n + 1)}{2}
   \]
2. Вычислить фактическую сумму элементов массива:
   \[
   S_{\text{actual}} = \sum_{i=0}^{k-1} numbers[i]
   \]
3. Найти отсутствующее число:
   \[
   missing = S_{\text{expected}} - S_{\text{actual}}
   \]

Вместо двойного цикла используется один проход по массиву:

`T(n) ≈ a * n + b`

**Асимптотическая сложность:**  
`T(n) = O(n)`

### Время выполнения программы при разных N

| N      | Среднее время (тики) |
|--------|----------------------|
| 100    | 128                  |
| 1 000  | 965                  |
| 5 000  | 4 945                |
| 10 000 | 9 789                |

Рост времени близок к линейному и значительно меньше, чем у квадратичного варианта.

### Пример работы программы (после рефакторинга)

```text
Отсутствующее число: 4
Время: 130 тиков
```

---

## Сравнение до и после рефакторинга

| Критерий             | До рефакторинга                             | После рефакторинга                          |
|----------------------|----------------------------------------------|---------------------------------------------|
| Алгоритм             | Двойной цикл, линейный поиск по массиву     | Формула суммы + один проход по массиву      |
| Сложность            | `O(n²)`                                     | `O(n)`                                      |
| Количество операций  | До `n * n` сравнений                        | `n` сложений                                |
| Масштабируемость     | Плохо масштабируется при больших `n`        | Хорошо масштабируется при больших `n`       |
| Реакция на рост N    | Время растет квадратично                    | Время растет почти линейно                  |

---

## Вывод

В исходной реализации поиск отсутствующего числа выполнялся с использованием двух вложенных циклов: для каждого возможного значения от `0` до `n` выполнялся линейный поиск по массиву. Такой подход приводил к квадратичной сложности `O(n²)` и заметному росту времени работы при увеличении размера входных данных.

После рефакторинга был применен более эффективный подход:

 используется математическая формула суммы чисел от `0` до `n`;
 выполняется один проход по массиву для вычисления фактической суммы;
 отсутствующее число определяется как разность ожидаемой и фактической сумм.

В результате:

 сложность алгоритма снижена с `O(n²)` до `O(n)`;
 алгоритм стал лучше масштабироваться для больших значений `n`;
